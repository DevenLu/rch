#!/usr/bin/env bash

# rch - CLI tool to replace characters on a set of files
#
# Replace character(s) with another one character(s)
# in a set of files given on a directory
#
# @param -o The old string to replace
#   e.g. "xyz"
# @param -n The new string that replaces the old one
#   e.g. "abc"
# @param -d The directory where the files to process are
#   e.g. "/home/you/foo/"
# @param -p The path with a pattern of the files to process (ommited if directory provided)
#   e.g. "/home/you/foo/*.txt"
# @param -b [OPTIONAL] A directory to place backups of every processed file
#   e.g. "/home/you/backup/foo"
#
# Credit where it's due.
# @author Lucio Mart√≠nez <luciomartinez@openmailbox.org>

readonly PACKAGE="rch"
readonly VERSION="0.1"
verbose=false


# Print message only if verbose mode is enabled
log() {
  [ $verbose == true ] && echo "$*" ||:
}


print_help() {
  echo "Usage: $PACKAGE [OPTION]... -o TARGET -n SOURCE -d DIRECTORY -p PATH [-b BACKUP]"
  echo "Replace character(s) TARGET with character(s) SOURCE in the files on DIRECTORY or PATH."
  echo " "
  echo "WARNING: be sure to don't place this file on the same directory than the one that you choice to process the files."
  echo " "
  echo "  -b                make a backup of each file processed on the BACKUP directory"
  echo "  -h, --help        display this help and exit"
  echo "  --version         output version information and exit"
  echo "  -v, --verbose     explain what is being done"
}


print_version() {
  echo "$PACKAGE $VERSION"
}


# @param error message
print_error() {
  echo "$PACKAGE: $*"
  echo "Try '$PACKAGE --help' for more information."
}


# @param path
create_directory_if_not_exists() {
  if [ ! -d $* ];
  then
    log " [+] Backup directory does not exist, creating it on '$BACKUP_DIR'..."
    mkdir -p $*
  fi
}

# DISABLED FUNCTION
# Reason: shouldn't the OS free the /tmp folder when needed?
#
# Remove every useles file generated by the application
# but do NOT remove the backup files generated intentionally
# remove_obsolete_files() {
#   rm $temp_file
# }


# @param 1. Old string to be replace
# @param 2. New string to replace old
# @param 3. File where string will be replaced
# @param 4. Temporary file to prevent data corruption (I am feeling optimistic)
replace_string_on_file() {
  log " [+] Replacing string '$1' with '$2' on file '$3'..."
  # Replace the strings on the file
  sed "s/$1/$2/g" "$3" > $4 && mv $4 "$3"
}


# @param 1. Old string stored on the file(s) to be replaced
# @param 2. New string that will replace the old one
# @param 3. Directory where the file to process are
# @param 4. Path with a pattern to the files to process (not used if Directory given)
# @param 5. Backup directory where each processed file will be copied (use value 0 for not backup)
# @param 6. ??
# @param 7. And of course, profit!
start_working() {
  local old="$1"
  local new="$2"
  local dir="$3"
  local path="$4"
  local f;
  local readonly BACKUP_DIR="$5";
  local readonly TEMP_FILE="/tmp/out.tmp.$$";

  # If backup is required, the directory has to exist
  if [ "$BACKUP_DIR" != 0 ];
  then
    create_directory_if_not_exists "$BACKUP_DIR"
  fi

  # If directory *and* pattern were given simoultaneusly
  # we are going to use directory only.
  # If you think I'm wrong, change it ;)
  if [ "$dir" != 0 ];
  then
    cd $dir
    path="`dir $dir`"
  fi

  # For every file in the path..
  for f in $path;
  do
    # Do nothing when processing the node to the actual dir
    # that is called '.' (yep, a dot) on linux
    if [ "$f" != '.' ];
    then
      # Check if it is a regular file
      # can be readable and writable
      if [ -f $f -a -r $f -a -w $f ];
      then
        log " [+] Processing file '$f'..."
        # Check if we need to make a backup
        if [ "$BACKUP_DIR" != 0 ];
        then
          # Now, please, do the backup
          log " [+] Making backup of file '$f'..."
          cp "$f" "../$BACKUP_DIR/"
        fi
        replace_string_on_file "$old" "$new" "$f" "$TEMP_FILE"
      else
       log " [-] WARNING: Cannot process file $f"
      fi
    fi
  done
}


main() {
  # Define required parameters here
  local r_old=0
  local r_new=0
  local r_target=0
  # Passed values
  local backup_dir=0
  local s_new=''
  local s_old=''
  local target_directory=0
  local target_path=0

  #getopts
  while test $# -gt 0; do
    case "$1" in
      -h|--help)
        print_help
        exit 0
        ;;
      --version)
        print_version
        exit 0
        ;;
      -v|--verbose)
        shift
          verbose=true
        shift
        ;;
      -b)
        shift
          if test $# -gt 0;
          then
            backup_dir="$1"
          else
            print_error "No backup directory specified"
            exit 1
          fi
        shift
        ;;
      -d)
        shift
          if test $# -gt 0;
          then
            target_directory="$1"
            r_target=1
          else
            print_error "No directory specified"
            exit 1
          fi
        shift
        ;;
      -n)
        shift
          if test $# -gt 0;
          then
            s_new="$1"
            r_new=1
          else
            print_error "No new string specified"
            exit 1
          fi
        shift
        ;;
      -o)
        shift
          if test $# -gt 0;
          then
            s_old="$1"
            r_old=1
          else
            print_error "No old string specified"
            exit 1
          fi
        shift
        ;;
      -p)
        shift
          if test $# -gt 0;
          then
            target_path="$1"
            r_target=1
          else
            print_error "No path specified"
            exit 1
          fi
        shift
        ;;
      *)
        print_error "invalid option: '$1'"
        exit 1
        ;;
    esac
  done

  # Check if all parameters were entered
  if [ "$r_old" -ne 1 -o "$r_new" -ne 1 -o "$r_target" -ne 1 ]
  then
    print_error "missing required operands"
    exit 1
  fi

  # Everything is ok.. Now lets work!
  start_working "$s_old" "$s_new" "$target_directory" "$target_path" "$backup_dir"
}

main "$@"
